// Code generated by msgpackgen. DO NOT EDIT.

package bench

import (
	"fmt"
	msgpack "github.com/shamaton/msgpackgen/msgpack"
	dec "github.com/shamaton/msgpackgen/msgpack/dec"
	enc "github.com/shamaton/msgpackgen/msgpack/enc"
)

// RegisterGeneratedResolver registers generated resolver.
func RegisterGeneratedResolver() {
	msgpack.SetResolver(___encodeAsMap, ___encodeAsArray, ___decodeAsMap, ___decodeAsArray)
}

// encode
func ___encode(i interface{}) ([]byte, error) {
	if msgpack.StructAsArray() {
		return ___encodeAsArray(i)
	} else {
		return ___encodeAsMap(i)
	}
}

// encodeAsArray
func ___encodeAsArray(i interface{}) ([]byte, error) {
	switch v := i.(type) {
	case BenchChild:
		encoder := enc.NewEncoder()
		size, err := ___calcArraySizeBenchChild_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(v, encoder)
		if err != nil {
			return nil, err
		}
		encoder.MakeBytes(size)
		b, offset, err := ___encodeArrayBenchChild_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(v, encoder, 0)
		if err != nil {
			return nil, err
		}
		if size != offset {
			return nil, fmt.Errorf("%s size / offset different %d : %d", "BenchChild", size, offset)
		}
		return b, err
	case *BenchChild:
		encoder := enc.NewEncoder()
		size, err := ___calcArraySizeBenchChild_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(*v, encoder)
		if err != nil {
			return nil, err
		}
		encoder.MakeBytes(size)
		b, offset, err := ___encodeArrayBenchChild_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(*v, encoder, 0)
		if err != nil {
			return nil, err
		}
		if size != offset {
			return nil, fmt.Errorf("%s size / offset different %d : %d", "BenchChild", size, offset)
		}
		return b, err
	case BenchMarkStruct:
		encoder := enc.NewEncoder()
		size, err := ___calcArraySizeBenchMarkStruct_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(v, encoder)
		if err != nil {
			return nil, err
		}
		encoder.MakeBytes(size)
		b, offset, err := ___encodeArrayBenchMarkStruct_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(v, encoder, 0)
		if err != nil {
			return nil, err
		}
		if size != offset {
			return nil, fmt.Errorf("%s size / offset different %d : %d", "BenchMarkStruct", size, offset)
		}
		return b, err
	case *BenchMarkStruct:
		encoder := enc.NewEncoder()
		size, err := ___calcArraySizeBenchMarkStruct_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(*v, encoder)
		if err != nil {
			return nil, err
		}
		encoder.MakeBytes(size)
		b, offset, err := ___encodeArrayBenchMarkStruct_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(*v, encoder, 0)
		if err != nil {
			return nil, err
		}
		if size != offset {
			return nil, fmt.Errorf("%s size / offset different %d : %d", "BenchMarkStruct", size, offset)
		}
		return b, err
	case Item:
		encoder := enc.NewEncoder()
		size, err := ___calcArraySizeItem_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(v, encoder)
		if err != nil {
			return nil, err
		}
		encoder.MakeBytes(size)
		b, offset, err := ___encodeArrayItem_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(v, encoder, 0)
		if err != nil {
			return nil, err
		}
		if size != offset {
			return nil, fmt.Errorf("%s size / offset different %d : %d", "Item", size, offset)
		}
		return b, err
	case *Item:
		encoder := enc.NewEncoder()
		size, err := ___calcArraySizeItem_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(*v, encoder)
		if err != nil {
			return nil, err
		}
		encoder.MakeBytes(size)
		b, offset, err := ___encodeArrayItem_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(*v, encoder, 0)
		if err != nil {
			return nil, err
		}
		if size != offset {
			return nil, fmt.Errorf("%s size / offset different %d : %d", "Item", size, offset)
		}
		return b, err
	case User:
		encoder := enc.NewEncoder()
		size, err := ___calcArraySizeUser_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(v, encoder)
		if err != nil {
			return nil, err
		}
		encoder.MakeBytes(size)
		b, offset, err := ___encodeArrayUser_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(v, encoder, 0)
		if err != nil {
			return nil, err
		}
		if size != offset {
			return nil, fmt.Errorf("%s size / offset different %d : %d", "User", size, offset)
		}
		return b, err
	case *User:
		encoder := enc.NewEncoder()
		size, err := ___calcArraySizeUser_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(*v, encoder)
		if err != nil {
			return nil, err
		}
		encoder.MakeBytes(size)
		b, offset, err := ___encodeArrayUser_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(*v, encoder, 0)
		if err != nil {
			return nil, err
		}
		if size != offset {
			return nil, fmt.Errorf("%s size / offset different %d : %d", "User", size, offset)
		}
		return b, err
	}
	return nil, nil
}

// encodeAsMap
func ___encodeAsMap(i interface{}) ([]byte, error) {
	switch v := i.(type) {
	case BenchChild:
		encoder := enc.NewEncoder()
		size, err := ___calcMapSizeBenchChild_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(v, encoder)
		if err != nil {
			return nil, err
		}
		encoder.MakeBytes(size)
		b, offset, err := ___encodeMapBenchChild_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(v, encoder, 0)
		if err != nil {
			return nil, err
		}
		if size != offset {
			return nil, fmt.Errorf("%s size / offset different %d : %d", "BenchChild", size, offset)
		}
		return b, err
	case *BenchChild:
		encoder := enc.NewEncoder()
		size, err := ___calcMapSizeBenchChild_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(*v, encoder)
		if err != nil {
			return nil, err
		}
		encoder.MakeBytes(size)
		b, offset, err := ___encodeMapBenchChild_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(*v, encoder, 0)
		if err != nil {
			return nil, err
		}
		if size != offset {
			return nil, fmt.Errorf("%s size / offset different %d : %d", "BenchChild", size, offset)
		}
		return b, err
	case BenchMarkStruct:
		encoder := enc.NewEncoder()
		size, err := ___calcMapSizeBenchMarkStruct_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(v, encoder)
		if err != nil {
			return nil, err
		}
		encoder.MakeBytes(size)
		b, offset, err := ___encodeMapBenchMarkStruct_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(v, encoder, 0)
		if err != nil {
			return nil, err
		}
		if size != offset {
			return nil, fmt.Errorf("%s size / offset different %d : %d", "BenchMarkStruct", size, offset)
		}
		return b, err
	case *BenchMarkStruct:
		encoder := enc.NewEncoder()
		size, err := ___calcMapSizeBenchMarkStruct_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(*v, encoder)
		if err != nil {
			return nil, err
		}
		encoder.MakeBytes(size)
		b, offset, err := ___encodeMapBenchMarkStruct_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(*v, encoder, 0)
		if err != nil {
			return nil, err
		}
		if size != offset {
			return nil, fmt.Errorf("%s size / offset different %d : %d", "BenchMarkStruct", size, offset)
		}
		return b, err
	case Item:
		encoder := enc.NewEncoder()
		size, err := ___calcMapSizeItem_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(v, encoder)
		if err != nil {
			return nil, err
		}
		encoder.MakeBytes(size)
		b, offset, err := ___encodeMapItem_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(v, encoder, 0)
		if err != nil {
			return nil, err
		}
		if size != offset {
			return nil, fmt.Errorf("%s size / offset different %d : %d", "Item", size, offset)
		}
		return b, err
	case *Item:
		encoder := enc.NewEncoder()
		size, err := ___calcMapSizeItem_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(*v, encoder)
		if err != nil {
			return nil, err
		}
		encoder.MakeBytes(size)
		b, offset, err := ___encodeMapItem_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(*v, encoder, 0)
		if err != nil {
			return nil, err
		}
		if size != offset {
			return nil, fmt.Errorf("%s size / offset different %d : %d", "Item", size, offset)
		}
		return b, err
	case User:
		encoder := enc.NewEncoder()
		size, err := ___calcMapSizeUser_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(v, encoder)
		if err != nil {
			return nil, err
		}
		encoder.MakeBytes(size)
		b, offset, err := ___encodeMapUser_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(v, encoder, 0)
		if err != nil {
			return nil, err
		}
		if size != offset {
			return nil, fmt.Errorf("%s size / offset different %d : %d", "User", size, offset)
		}
		return b, err
	case *User:
		encoder := enc.NewEncoder()
		size, err := ___calcMapSizeUser_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(*v, encoder)
		if err != nil {
			return nil, err
		}
		encoder.MakeBytes(size)
		b, offset, err := ___encodeMapUser_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(*v, encoder, 0)
		if err != nil {
			return nil, err
		}
		if size != offset {
			return nil, fmt.Errorf("%s size / offset different %d : %d", "User", size, offset)
		}
		return b, err
	}
	return nil, nil
}

// decode
func ___decode(data []byte, i interface{}) (bool, error) {
	if msgpack.StructAsArray() {
		return ___decodeAsArray(data, i)
	} else {
		return ___decodeAsMap(data, i)
	}
}

// decodeAsArray
func ___decodeAsArray(data []byte, i interface{}) (bool, error) {
	switch v := i.(type) {
	case *BenchChild:
		decoder := dec.NewDecoder(data)
		offset, err := ___decodeArrayBenchChild_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(v, decoder, 0)
		if err == nil && offset != decoder.Len() {
			return true, fmt.Errorf("read length is different [%d] [%d] ", offset, decoder.Len())
		}
		return true, err
	case **BenchChild:
		decoder := dec.NewDecoder(data)
		offset, err := ___decodeArrayBenchChild_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(*v, decoder, 0)
		if err == nil && offset != decoder.Len() {
			return true, fmt.Errorf("read length is different [%d] [%d] ", offset, decoder.Len())
		}
		return true, err
	case *BenchMarkStruct:
		decoder := dec.NewDecoder(data)
		offset, err := ___decodeArrayBenchMarkStruct_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(v, decoder, 0)
		if err == nil && offset != decoder.Len() {
			return true, fmt.Errorf("read length is different [%d] [%d] ", offset, decoder.Len())
		}
		return true, err
	case **BenchMarkStruct:
		decoder := dec.NewDecoder(data)
		offset, err := ___decodeArrayBenchMarkStruct_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(*v, decoder, 0)
		if err == nil && offset != decoder.Len() {
			return true, fmt.Errorf("read length is different [%d] [%d] ", offset, decoder.Len())
		}
		return true, err
	case *Item:
		decoder := dec.NewDecoder(data)
		offset, err := ___decodeArrayItem_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(v, decoder, 0)
		if err == nil && offset != decoder.Len() {
			return true, fmt.Errorf("read length is different [%d] [%d] ", offset, decoder.Len())
		}
		return true, err
	case **Item:
		decoder := dec.NewDecoder(data)
		offset, err := ___decodeArrayItem_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(*v, decoder, 0)
		if err == nil && offset != decoder.Len() {
			return true, fmt.Errorf("read length is different [%d] [%d] ", offset, decoder.Len())
		}
		return true, err
	case *User:
		decoder := dec.NewDecoder(data)
		offset, err := ___decodeArrayUser_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(v, decoder, 0)
		if err == nil && offset != decoder.Len() {
			return true, fmt.Errorf("read length is different [%d] [%d] ", offset, decoder.Len())
		}
		return true, err
	case **User:
		decoder := dec.NewDecoder(data)
		offset, err := ___decodeArrayUser_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(*v, decoder, 0)
		if err == nil && offset != decoder.Len() {
			return true, fmt.Errorf("read length is different [%d] [%d] ", offset, decoder.Len())
		}
		return true, err
	}
	return false, nil
}

// decodeAsMap
func ___decodeAsMap(data []byte, i interface{}) (bool, error) {
	switch v := i.(type) {
	case *BenchChild:
		decoder := dec.NewDecoder(data)
		offset, err := ___decodeMapBenchChild_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(v, decoder, 0)
		if err == nil && offset != decoder.Len() {
			return true, fmt.Errorf("read length is different [%d] [%d] ", offset, decoder.Len())
		}
		return true, err
	case **BenchChild:
		decoder := dec.NewDecoder(data)
		offset, err := ___decodeMapBenchChild_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(*v, decoder, 0)
		if err == nil && offset != decoder.Len() {
			return true, fmt.Errorf("read length is different [%d] [%d] ", offset, decoder.Len())
		}
		return true, err
	case *BenchMarkStruct:
		decoder := dec.NewDecoder(data)
		offset, err := ___decodeMapBenchMarkStruct_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(v, decoder, 0)
		if err == nil && offset != decoder.Len() {
			return true, fmt.Errorf("read length is different [%d] [%d] ", offset, decoder.Len())
		}
		return true, err
	case **BenchMarkStruct:
		decoder := dec.NewDecoder(data)
		offset, err := ___decodeMapBenchMarkStruct_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(*v, decoder, 0)
		if err == nil && offset != decoder.Len() {
			return true, fmt.Errorf("read length is different [%d] [%d] ", offset, decoder.Len())
		}
		return true, err
	case *Item:
		decoder := dec.NewDecoder(data)
		offset, err := ___decodeMapItem_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(v, decoder, 0)
		if err == nil && offset != decoder.Len() {
			return true, fmt.Errorf("read length is different [%d] [%d] ", offset, decoder.Len())
		}
		return true, err
	case **Item:
		decoder := dec.NewDecoder(data)
		offset, err := ___decodeMapItem_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(*v, decoder, 0)
		if err == nil && offset != decoder.Len() {
			return true, fmt.Errorf("read length is different [%d] [%d] ", offset, decoder.Len())
		}
		return true, err
	case *User:
		decoder := dec.NewDecoder(data)
		offset, err := ___decodeMapUser_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(v, decoder, 0)
		if err == nil && offset != decoder.Len() {
			return true, fmt.Errorf("read length is different [%d] [%d] ", offset, decoder.Len())
		}
		return true, err
	case **User:
		decoder := dec.NewDecoder(data)
		offset, err := ___decodeMapUser_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(*v, decoder, 0)
		if err == nil && offset != decoder.Len() {
			return true, fmt.Errorf("read length is different [%d] [%d] ", offset, decoder.Len())
		}
		return true, err
	}
	return false, nil
}

// calculate size from github.com/shamaton/msgpack_bench.BenchChild
func ___calcArraySizeBenchChild_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(v BenchChild, encoder *enc.Encoder) (int, error) {
	size := 0
	size += encoder.CalcStructHeaderFix(2)
	size += encoder.CalcInt(v.Int)
	size += encoder.CalcString(v.String)
	return size, nil
}

// calculate size from github.com/shamaton/msgpack_bench.BenchChild
func ___calcMapSizeBenchChild_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(v BenchChild, encoder *enc.Encoder) (int, error) {
	size := 0
	size += encoder.CalcStructHeaderFix(2)
	size += encoder.CalcStringFix(3)
	size += encoder.CalcInt(v.Int)
	size += encoder.CalcStringFix(6)
	size += encoder.CalcString(v.String)
	return size, nil
}

// encode from github.com/shamaton/msgpack_bench.BenchChild
func ___encodeArrayBenchChild_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(v BenchChild, encoder *enc.Encoder, offset int) ([]byte, int, error) {
	var err error
	offset = encoder.WriteStructHeaderFixAsArray(2, offset)
	offset = encoder.WriteInt(v.Int, offset)
	offset = encoder.WriteString(v.String, offset)
	return encoder.EncodedBytes(), offset, err
}

// encode from github.com/shamaton/msgpack_bench.BenchChild
func ___encodeMapBenchChild_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(v BenchChild, encoder *enc.Encoder, offset int) ([]byte, int, error) {
	var err error
	offset = encoder.WriteStructHeaderFixAsMap(2, offset)
	offset = encoder.WriteStringFix("Int", 3, offset)
	offset = encoder.WriteInt(v.Int, offset)
	offset = encoder.WriteStringFix("String", 6, offset)
	offset = encoder.WriteString(v.String, offset)
	return encoder.EncodedBytes(), offset, err
}

// decode to github.com/shamaton/msgpack_bench.BenchChild
func ___decodeArrayBenchChild_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(v *BenchChild, decoder *dec.Decoder, offset int) (int, error) {
	offset, err := decoder.CheckStructHeader(2, offset)
	if err != nil {
		return 0, err
	}
	{
		var vv int
		vv, offset, err = decoder.AsInt(offset)
		if err != nil {
			return 0, err
		}
		v.Int = vv
	}
	{
		var vv string
		vv, offset, err = decoder.AsString(offset)
		if err != nil {
			return 0, err
		}
		v.String = vv
	}
	return offset, err
}

// decode to github.com/shamaton/msgpack_bench.BenchChild
func ___decodeMapBenchChild_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(v *BenchChild, decoder *dec.Decoder, offset int) (int, error) {
	offset, err := decoder.CheckStructHeader(2, offset)
	if err != nil {
		return 0, err
	}
	count := 0
	for count < 2 {
		var s string
		s, offset, err = decoder.AsString(offset)
		if err != nil {
			return 0, err
		}
		switch s {
		case "Int":
			{
				var vv int
				vv, offset, err = decoder.AsInt(offset)
				if err != nil {
					return 0, err
				}
				v.Int = vv
			}
			count++
		case "String":
			{
				var vv string
				vv, offset, err = decoder.AsString(offset)
				if err != nil {
					return 0, err
				}
				v.String = vv
			}
			count++
		default:
			return 0, fmt.Errorf("unknown key[%s] found", s)
		}
	}
	return offset, err
}

// calculate size from github.com/shamaton/msgpack_bench.BenchMarkStruct
func ___calcArraySizeBenchMarkStruct_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(v BenchMarkStruct, encoder *enc.Encoder) (int, error) {
	size := 0
	size += encoder.CalcStructHeaderFix(9)
	size += encoder.CalcInt(v.Int)
	size += encoder.CalcUint(v.Uint)
	size += encoder.CalcFloat32(v.Float)
	size += encoder.CalcFloat64(v.Double)
	size += encoder.CalcBool(v.Bool)
	size += encoder.CalcString(v.String)
	if v.Array != nil {
		s, err := encoder.CalcSliceLength(len(v.Array), false)
		if err != nil {
			return 0, err
		}
		size += s
		for _, vv := range v.Array {
			size += encoder.CalcInt(vv)
		}
	} else {
		size += encoder.CalcNil()
	}
	if v.Map != nil {
		s, err := encoder.CalcMapLength(len(v.Map))
		if err != nil {
			return 0, err
		}
		size += s
		for kk, vv := range v.Map {
			size += encoder.CalcString(kk)
			size += encoder.CalcUint(vv)
		}
	} else {
		size += encoder.CalcNil()
	}
	size_v_Child, err := ___calcArraySizeBenchChild_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(v.Child, encoder)
	if err != nil {
		return 0, err
	}
	size += size_v_Child
	return size, nil
}

// calculate size from github.com/shamaton/msgpack_bench.BenchMarkStruct
func ___calcMapSizeBenchMarkStruct_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(v BenchMarkStruct, encoder *enc.Encoder) (int, error) {
	size := 0
	size += encoder.CalcStructHeaderFix(9)
	size += encoder.CalcStringFix(3)
	size += encoder.CalcInt(v.Int)
	size += encoder.CalcStringFix(4)
	size += encoder.CalcUint(v.Uint)
	size += encoder.CalcStringFix(5)
	size += encoder.CalcFloat32(v.Float)
	size += encoder.CalcStringFix(6)
	size += encoder.CalcFloat64(v.Double)
	size += encoder.CalcStringFix(4)
	size += encoder.CalcBool(v.Bool)
	size += encoder.CalcStringFix(6)
	size += encoder.CalcString(v.String)
	size += encoder.CalcStringFix(5)
	if v.Array != nil {
		s, err := encoder.CalcSliceLength(len(v.Array), false)
		if err != nil {
			return 0, err
		}
		size += s
		for _, vv := range v.Array {
			size += encoder.CalcInt(vv)
		}
	} else {
		size += encoder.CalcNil()
	}
	size += encoder.CalcStringFix(3)
	if v.Map != nil {
		s, err := encoder.CalcMapLength(len(v.Map))
		if err != nil {
			return 0, err
		}
		size += s
		for kk, vv := range v.Map {
			size += encoder.CalcString(kk)
			size += encoder.CalcUint(vv)
		}
	} else {
		size += encoder.CalcNil()
	}
	size += encoder.CalcStringFix(5)
	size_v_Child, err := ___calcMapSizeBenchChild_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(v.Child, encoder)
	if err != nil {
		return 0, err
	}
	size += size_v_Child
	return size, nil
}

// encode from github.com/shamaton/msgpack_bench.BenchMarkStruct
func ___encodeArrayBenchMarkStruct_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(v BenchMarkStruct, encoder *enc.Encoder, offset int) ([]byte, int, error) {
	var err error
	offset = encoder.WriteStructHeaderFixAsArray(9, offset)
	offset = encoder.WriteInt(v.Int, offset)
	offset = encoder.WriteUint(v.Uint, offset)
	offset = encoder.WriteFloat32(v.Float, offset)
	offset = encoder.WriteFloat64(v.Double, offset)
	offset = encoder.WriteBool(v.Bool, offset)
	offset = encoder.WriteString(v.String, offset)
	if v.Array != nil {
		offset = encoder.WriteSliceLength(len(v.Array), offset, false)
		for _, vv := range v.Array {
			offset = encoder.WriteInt(vv, offset)
		}
	} else {
		offset = encoder.WriteNil(offset)
	}
	if v.Map != nil {
		offset = encoder.WriteMapLength(len(v.Map), offset)
		for kk, vv := range v.Map {
			offset = encoder.WriteString(kk, offset)
			offset = encoder.WriteUint(vv, offset)
		}
	} else {
		offset = encoder.WriteNil(offset)
	}
	_, offset, err = ___encodeArrayBenchChild_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(v.Child, encoder, offset)
	if err != nil {
		return nil, 0, err
	}
	return encoder.EncodedBytes(), offset, err
}

// encode from github.com/shamaton/msgpack_bench.BenchMarkStruct
func ___encodeMapBenchMarkStruct_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(v BenchMarkStruct, encoder *enc.Encoder, offset int) ([]byte, int, error) {
	var err error
	offset = encoder.WriteStructHeaderFixAsMap(9, offset)
	offset = encoder.WriteStringFix("Int", 3, offset)
	offset = encoder.WriteInt(v.Int, offset)
	offset = encoder.WriteStringFix("Uint", 4, offset)
	offset = encoder.WriteUint(v.Uint, offset)
	offset = encoder.WriteStringFix("Float", 5, offset)
	offset = encoder.WriteFloat32(v.Float, offset)
	offset = encoder.WriteStringFix("Double", 6, offset)
	offset = encoder.WriteFloat64(v.Double, offset)
	offset = encoder.WriteStringFix("Bool", 4, offset)
	offset = encoder.WriteBool(v.Bool, offset)
	offset = encoder.WriteStringFix("String", 6, offset)
	offset = encoder.WriteString(v.String, offset)
	offset = encoder.WriteStringFix("Array", 5, offset)
	if v.Array != nil {
		offset = encoder.WriteSliceLength(len(v.Array), offset, false)
		for _, vv := range v.Array {
			offset = encoder.WriteInt(vv, offset)
		}
	} else {
		offset = encoder.WriteNil(offset)
	}
	offset = encoder.WriteStringFix("Map", 3, offset)
	if v.Map != nil {
		offset = encoder.WriteMapLength(len(v.Map), offset)
		for kk, vv := range v.Map {
			offset = encoder.WriteString(kk, offset)
			offset = encoder.WriteUint(vv, offset)
		}
	} else {
		offset = encoder.WriteNil(offset)
	}
	offset = encoder.WriteStringFix("Child", 5, offset)
	_, offset, err = ___encodeMapBenchChild_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(v.Child, encoder, offset)
	if err != nil {
		return nil, 0, err
	}
	return encoder.EncodedBytes(), offset, err
}

// decode to github.com/shamaton/msgpack_bench.BenchMarkStruct
func ___decodeArrayBenchMarkStruct_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(v *BenchMarkStruct, decoder *dec.Decoder, offset int) (int, error) {
	offset, err := decoder.CheckStructHeader(9, offset)
	if err != nil {
		return 0, err
	}
	{
		var vv int
		vv, offset, err = decoder.AsInt(offset)
		if err != nil {
			return 0, err
		}
		v.Int = vv
	}
	{
		var vv uint
		vv, offset, err = decoder.AsUint(offset)
		if err != nil {
			return 0, err
		}
		v.Uint = vv
	}
	{
		var vv float32
		vv, offset, err = decoder.AsFloat32(offset)
		if err != nil {
			return 0, err
		}
		v.Float = vv
	}
	{
		var vv float64
		vv, offset, err = decoder.AsFloat64(offset)
		if err != nil {
			return 0, err
		}
		v.Double = vv
	}
	{
		var vv bool
		vv, offset, err = decoder.AsBool(offset)
		if err != nil {
			return 0, err
		}
		v.Bool = vv
	}
	{
		var vv string
		vv, offset, err = decoder.AsString(offset)
		if err != nil {
			return 0, err
		}
		v.String = vv
	}
	if !decoder.IsCodeNil(offset) {
		var vv []int
		var vvl int
		vvl, offset, err = decoder.SliceLength(offset)
		if err != nil {
			return 0, err
		}
		vv = make([]int, vvl)
		for vvi := range vv {
			var vvv int
			vvv, offset, err = decoder.AsInt(offset)
			if err != nil {
				return 0, err
			}
			vv[vvi] = vvv
		}
		v.Array = vv
	} else {
		offset++
	}
	if !decoder.IsCodeNil(offset) {
		var vv map[string]uint
		var vvl int
		vvl, offset, err = decoder.MapLength(offset)
		if err != nil {
			return 0, err
		}
		vv = make(map[string]uint, vvl)
		for vvi := 0; vvi < vvl; vvi++ {
			var kkv string
			kkv, offset, err = decoder.AsString(offset)
			if err != nil {
				return 0, err
			}
			var vvv uint
			vvv, offset, err = decoder.AsUint(offset)
			if err != nil {
				return 0, err
			}
			vv[kkv] = vvv
		}
		v.Map = vv
	} else {
		offset++
	}
	{
		var vv BenchChild
		offset, err = ___decodeArrayBenchChild_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(&vv, decoder, offset)
		if err != nil {
			return 0, err
		}
		v.Child = vv
	}
	return offset, err
}

// decode to github.com/shamaton/msgpack_bench.BenchMarkStruct
func ___decodeMapBenchMarkStruct_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(v *BenchMarkStruct, decoder *dec.Decoder, offset int) (int, error) {
	offset, err := decoder.CheckStructHeader(9, offset)
	if err != nil {
		return 0, err
	}
	count := 0
	for count < 9 {
		var s string
		s, offset, err = decoder.AsString(offset)
		if err != nil {
			return 0, err
		}
		switch s {
		case "Int":
			{
				var vv int
				vv, offset, err = decoder.AsInt(offset)
				if err != nil {
					return 0, err
				}
				v.Int = vv
			}
			count++
		case "Uint":
			{
				var vv uint
				vv, offset, err = decoder.AsUint(offset)
				if err != nil {
					return 0, err
				}
				v.Uint = vv
			}
			count++
		case "Float":
			{
				var vv float32
				vv, offset, err = decoder.AsFloat32(offset)
				if err != nil {
					return 0, err
				}
				v.Float = vv
			}
			count++
		case "Double":
			{
				var vv float64
				vv, offset, err = decoder.AsFloat64(offset)
				if err != nil {
					return 0, err
				}
				v.Double = vv
			}
			count++
		case "Bool":
			{
				var vv bool
				vv, offset, err = decoder.AsBool(offset)
				if err != nil {
					return 0, err
				}
				v.Bool = vv
			}
			count++
		case "String":
			{
				var vv string
				vv, offset, err = decoder.AsString(offset)
				if err != nil {
					return 0, err
				}
				v.String = vv
			}
			count++
		case "Array":
			if !decoder.IsCodeNil(offset) {
				var vv []int
				var vvl int
				vvl, offset, err = decoder.SliceLength(offset)
				if err != nil {
					return 0, err
				}
				vv = make([]int, vvl)
				for vvi := range vv {
					var vvv int
					vvv, offset, err = decoder.AsInt(offset)
					if err != nil {
						return 0, err
					}
					vv[vvi] = vvv
				}
				v.Array = vv
			} else {
				offset++
			}
			count++
		case "Map":
			if !decoder.IsCodeNil(offset) {
				var vv map[string]uint
				var vvl int
				vvl, offset, err = decoder.MapLength(offset)
				if err != nil {
					return 0, err
				}
				vv = make(map[string]uint, vvl)
				for vvi := 0; vvi < vvl; vvi++ {
					var kkv string
					kkv, offset, err = decoder.AsString(offset)
					if err != nil {
						return 0, err
					}
					var vvv uint
					vvv, offset, err = decoder.AsUint(offset)
					if err != nil {
						return 0, err
					}
					vv[kkv] = vvv
				}
				v.Map = vv
			} else {
				offset++
			}
			count++
		case "Child":
			{
				var vv BenchChild
				offset, err = ___decodeMapBenchChild_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(&vv, decoder, offset)
				if err != nil {
					return 0, err
				}
				v.Child = vv
			}
			count++
		default:
			return 0, fmt.Errorf("unknown key[%s] found", s)
		}
	}
	return offset, err
}

// calculate size from github.com/shamaton/msgpack_bench.Item
func ___calcArraySizeItem_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(v Item, encoder *enc.Encoder) (int, error) {
	size := 0
	size += encoder.CalcStructHeaderFix(4)
	size += encoder.CalcInt(v.ID)
	size += encoder.CalcString(v.Name)
	size += encoder.CalcFloat32(v.Effect)
	size += encoder.CalcUint(v.Num)
	return size, nil
}

// calculate size from github.com/shamaton/msgpack_bench.Item
func ___calcMapSizeItem_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(v Item, encoder *enc.Encoder) (int, error) {
	size := 0
	size += encoder.CalcStructHeaderFix(4)
	size += encoder.CalcStringFix(2)
	size += encoder.CalcInt(v.ID)
	size += encoder.CalcStringFix(4)
	size += encoder.CalcString(v.Name)
	size += encoder.CalcStringFix(6)
	size += encoder.CalcFloat32(v.Effect)
	size += encoder.CalcStringFix(3)
	size += encoder.CalcUint(v.Num)
	return size, nil
}

// encode from github.com/shamaton/msgpack_bench.Item
func ___encodeArrayItem_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(v Item, encoder *enc.Encoder, offset int) ([]byte, int, error) {
	var err error
	offset = encoder.WriteStructHeaderFixAsArray(4, offset)
	offset = encoder.WriteInt(v.ID, offset)
	offset = encoder.WriteString(v.Name, offset)
	offset = encoder.WriteFloat32(v.Effect, offset)
	offset = encoder.WriteUint(v.Num, offset)
	return encoder.EncodedBytes(), offset, err
}

// encode from github.com/shamaton/msgpack_bench.Item
func ___encodeMapItem_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(v Item, encoder *enc.Encoder, offset int) ([]byte, int, error) {
	var err error
	offset = encoder.WriteStructHeaderFixAsMap(4, offset)
	offset = encoder.WriteStringFix("ID", 2, offset)
	offset = encoder.WriteInt(v.ID, offset)
	offset = encoder.WriteStringFix("Name", 4, offset)
	offset = encoder.WriteString(v.Name, offset)
	offset = encoder.WriteStringFix("Effect", 6, offset)
	offset = encoder.WriteFloat32(v.Effect, offset)
	offset = encoder.WriteStringFix("Num", 3, offset)
	offset = encoder.WriteUint(v.Num, offset)
	return encoder.EncodedBytes(), offset, err
}

// decode to github.com/shamaton/msgpack_bench.Item
func ___decodeArrayItem_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(v *Item, decoder *dec.Decoder, offset int) (int, error) {
	offset, err := decoder.CheckStructHeader(4, offset)
	if err != nil {
		return 0, err
	}
	{
		var vv int
		vv, offset, err = decoder.AsInt(offset)
		if err != nil {
			return 0, err
		}
		v.ID = vv
	}
	{
		var vv string
		vv, offset, err = decoder.AsString(offset)
		if err != nil {
			return 0, err
		}
		v.Name = vv
	}
	{
		var vv float32
		vv, offset, err = decoder.AsFloat32(offset)
		if err != nil {
			return 0, err
		}
		v.Effect = vv
	}
	{
		var vv uint
		vv, offset, err = decoder.AsUint(offset)
		if err != nil {
			return 0, err
		}
		v.Num = vv
	}
	return offset, err
}

// decode to github.com/shamaton/msgpack_bench.Item
func ___decodeMapItem_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(v *Item, decoder *dec.Decoder, offset int) (int, error) {
	offset, err := decoder.CheckStructHeader(4, offset)
	if err != nil {
		return 0, err
	}
	count := 0
	for count < 4 {
		var s string
		s, offset, err = decoder.AsString(offset)
		if err != nil {
			return 0, err
		}
		switch s {
		case "ID":
			{
				var vv int
				vv, offset, err = decoder.AsInt(offset)
				if err != nil {
					return 0, err
				}
				v.ID = vv
			}
			count++
		case "Name":
			{
				var vv string
				vv, offset, err = decoder.AsString(offset)
				if err != nil {
					return 0, err
				}
				v.Name = vv
			}
			count++
		case "Effect":
			{
				var vv float32
				vv, offset, err = decoder.AsFloat32(offset)
				if err != nil {
					return 0, err
				}
				v.Effect = vv
			}
			count++
		case "Num":
			{
				var vv uint
				vv, offset, err = decoder.AsUint(offset)
				if err != nil {
					return 0, err
				}
				v.Num = vv
			}
			count++
		default:
			return 0, fmt.Errorf("unknown key[%s] found", s)
		}
	}
	return offset, err
}

// calculate size from github.com/shamaton/msgpack_bench.User
func ___calcArraySizeUser_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(v User, encoder *enc.Encoder) (int, error) {
	size := 0
	size += encoder.CalcStructHeaderFix(7)
	size += encoder.CalcInt(v.ID)
	size += encoder.CalcString(v.Name)
	size += encoder.CalcUint(v.Level)
	size += encoder.CalcUint64(v.Exp)
	size += encoder.CalcBool(v.Type)
	if v.EquipIDs != nil {
		s, err := encoder.CalcSliceLength(len(v.EquipIDs), false)
		if err != nil {
			return 0, err
		}
		size += s
		for _, vv := range v.EquipIDs {
			size += encoder.CalcUint32(vv)
		}
	} else {
		size += encoder.CalcNil()
	}
	if v.Items != nil {
		s, err := encoder.CalcSliceLength(len(v.Items), false)
		if err != nil {
			return 0, err
		}
		size += s
		for _, vv := range v.Items {
			size_vv, err := ___calcArraySizeItem_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(vv, encoder)
			if err != nil {
				return 0, err
			}
			size += size_vv
		}
	} else {
		size += encoder.CalcNil()
	}
	return size, nil
}

// calculate size from github.com/shamaton/msgpack_bench.User
func ___calcMapSizeUser_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(v User, encoder *enc.Encoder) (int, error) {
	size := 0
	size += encoder.CalcStructHeaderFix(7)
	size += encoder.CalcStringFix(2)
	size += encoder.CalcInt(v.ID)
	size += encoder.CalcStringFix(4)
	size += encoder.CalcString(v.Name)
	size += encoder.CalcStringFix(5)
	size += encoder.CalcUint(v.Level)
	size += encoder.CalcStringFix(3)
	size += encoder.CalcUint64(v.Exp)
	size += encoder.CalcStringFix(4)
	size += encoder.CalcBool(v.Type)
	size += encoder.CalcStringFix(8)
	if v.EquipIDs != nil {
		s, err := encoder.CalcSliceLength(len(v.EquipIDs), false)
		if err != nil {
			return 0, err
		}
		size += s
		for _, vv := range v.EquipIDs {
			size += encoder.CalcUint32(vv)
		}
	} else {
		size += encoder.CalcNil()
	}
	size += encoder.CalcStringFix(5)
	if v.Items != nil {
		s, err := encoder.CalcSliceLength(len(v.Items), false)
		if err != nil {
			return 0, err
		}
		size += s
		for _, vv := range v.Items {
			size_vv, err := ___calcMapSizeItem_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(vv, encoder)
			if err != nil {
				return 0, err
			}
			size += size_vv
		}
	} else {
		size += encoder.CalcNil()
	}
	return size, nil
}

// encode from github.com/shamaton/msgpack_bench.User
func ___encodeArrayUser_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(v User, encoder *enc.Encoder, offset int) ([]byte, int, error) {
	var err error
	offset = encoder.WriteStructHeaderFixAsArray(7, offset)
	offset = encoder.WriteInt(v.ID, offset)
	offset = encoder.WriteString(v.Name, offset)
	offset = encoder.WriteUint(v.Level, offset)
	offset = encoder.WriteUint64(v.Exp, offset)
	offset = encoder.WriteBool(v.Type, offset)
	if v.EquipIDs != nil {
		offset = encoder.WriteSliceLength(len(v.EquipIDs), offset, false)
		for _, vv := range v.EquipIDs {
			offset = encoder.WriteUint32(vv, offset)
		}
	} else {
		offset = encoder.WriteNil(offset)
	}
	if v.Items != nil {
		offset = encoder.WriteSliceLength(len(v.Items), offset, false)
		for _, vv := range v.Items {
			_, offset, err = ___encodeArrayItem_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(vv, encoder, offset)
			if err != nil {
				return nil, 0, err
			}
		}
	} else {
		offset = encoder.WriteNil(offset)
	}
	return encoder.EncodedBytes(), offset, err
}

// encode from github.com/shamaton/msgpack_bench.User
func ___encodeMapUser_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(v User, encoder *enc.Encoder, offset int) ([]byte, int, error) {
	var err error
	offset = encoder.WriteStructHeaderFixAsMap(7, offset)
	offset = encoder.WriteStringFix("ID", 2, offset)
	offset = encoder.WriteInt(v.ID, offset)
	offset = encoder.WriteStringFix("Name", 4, offset)
	offset = encoder.WriteString(v.Name, offset)
	offset = encoder.WriteStringFix("Level", 5, offset)
	offset = encoder.WriteUint(v.Level, offset)
	offset = encoder.WriteStringFix("Exp", 3, offset)
	offset = encoder.WriteUint64(v.Exp, offset)
	offset = encoder.WriteStringFix("Type", 4, offset)
	offset = encoder.WriteBool(v.Type, offset)
	offset = encoder.WriteStringFix("EquipIDs", 8, offset)
	if v.EquipIDs != nil {
		offset = encoder.WriteSliceLength(len(v.EquipIDs), offset, false)
		for _, vv := range v.EquipIDs {
			offset = encoder.WriteUint32(vv, offset)
		}
	} else {
		offset = encoder.WriteNil(offset)
	}
	offset = encoder.WriteStringFix("Items", 5, offset)
	if v.Items != nil {
		offset = encoder.WriteSliceLength(len(v.Items), offset, false)
		for _, vv := range v.Items {
			_, offset, err = ___encodeMapItem_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(vv, encoder, offset)
			if err != nil {
				return nil, 0, err
			}
		}
	} else {
		offset = encoder.WriteNil(offset)
	}
	return encoder.EncodedBytes(), offset, err
}

// decode to github.com/shamaton/msgpack_bench.User
func ___decodeArrayUser_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(v *User, decoder *dec.Decoder, offset int) (int, error) {
	offset, err := decoder.CheckStructHeader(7, offset)
	if err != nil {
		return 0, err
	}
	{
		var vv int
		vv, offset, err = decoder.AsInt(offset)
		if err != nil {
			return 0, err
		}
		v.ID = vv
	}
	{
		var vv string
		vv, offset, err = decoder.AsString(offset)
		if err != nil {
			return 0, err
		}
		v.Name = vv
	}
	{
		var vv uint
		vv, offset, err = decoder.AsUint(offset)
		if err != nil {
			return 0, err
		}
		v.Level = vv
	}
	{
		var vv uint64
		vv, offset, err = decoder.AsUint64(offset)
		if err != nil {
			return 0, err
		}
		v.Exp = vv
	}
	{
		var vv bool
		vv, offset, err = decoder.AsBool(offset)
		if err != nil {
			return 0, err
		}
		v.Type = vv
	}
	if !decoder.IsCodeNil(offset) {
		var vv []uint32
		var vvl int
		vvl, offset, err = decoder.SliceLength(offset)
		if err != nil {
			return 0, err
		}
		vv = make([]uint32, vvl)
		for vvi := range vv {
			var vvv uint32
			vvv, offset, err = decoder.AsUint32(offset)
			if err != nil {
				return 0, err
			}
			vv[vvi] = vvv
		}
		v.EquipIDs = vv
	} else {
		offset++
	}
	if !decoder.IsCodeNil(offset) {
		var vv []Item
		var vvl int
		vvl, offset, err = decoder.SliceLength(offset)
		if err != nil {
			return 0, err
		}
		vv = make([]Item, vvl)
		for vvi := range vv {
			var vvv Item
			offset, err = ___decodeArrayItem_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(&vvv, decoder, offset)
			if err != nil {
				return 0, err
			}
			vv[vvi] = vvv
		}
		v.Items = vv
	} else {
		offset++
	}
	return offset, err
}

// decode to github.com/shamaton/msgpack_bench.User
func ___decodeMapUser_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(v *User, decoder *dec.Decoder, offset int) (int, error) {
	offset, err := decoder.CheckStructHeader(7, offset)
	if err != nil {
		return 0, err
	}
	count := 0
	for count < 7 {
		var s string
		s, offset, err = decoder.AsString(offset)
		if err != nil {
			return 0, err
		}
		switch s {
		case "ID":
			{
				var vv int
				vv, offset, err = decoder.AsInt(offset)
				if err != nil {
					return 0, err
				}
				v.ID = vv
			}
			count++
		case "Name":
			{
				var vv string
				vv, offset, err = decoder.AsString(offset)
				if err != nil {
					return 0, err
				}
				v.Name = vv
			}
			count++
		case "Level":
			{
				var vv uint
				vv, offset, err = decoder.AsUint(offset)
				if err != nil {
					return 0, err
				}
				v.Level = vv
			}
			count++
		case "Exp":
			{
				var vv uint64
				vv, offset, err = decoder.AsUint64(offset)
				if err != nil {
					return 0, err
				}
				v.Exp = vv
			}
			count++
		case "Type":
			{
				var vv bool
				vv, offset, err = decoder.AsBool(offset)
				if err != nil {
					return 0, err
				}
				v.Type = vv
			}
			count++
		case "EquipIDs":
			if !decoder.IsCodeNil(offset) {
				var vv []uint32
				var vvl int
				vvl, offset, err = decoder.SliceLength(offset)
				if err != nil {
					return 0, err
				}
				vv = make([]uint32, vvl)
				for vvi := range vv {
					var vvv uint32
					vvv, offset, err = decoder.AsUint32(offset)
					if err != nil {
						return 0, err
					}
					vv[vvi] = vvv
				}
				v.EquipIDs = vv
			} else {
				offset++
			}
			count++
		case "Items":
			if !decoder.IsCodeNil(offset) {
				var vv []Item
				var vvl int
				vvl, offset, err = decoder.SliceLength(offset)
				if err != nil {
					return 0, err
				}
				vv = make([]Item, vvl)
				for vvi := range vv {
					var vvv Item
					offset, err = ___decodeMapItem_e9fd2a14c1c378bd04d30694c76be6bdbcc546cb500c6f8829a44a1c9a8a1dfc(&vvv, decoder, offset)
					if err != nil {
						return 0, err
					}
					vv[vvi] = vvv
				}
				v.Items = vv
			} else {
				offset++
			}
			count++
		default:
			return 0, fmt.Errorf("unknown key[%s] found", s)
		}
	}
	return offset, err
}
